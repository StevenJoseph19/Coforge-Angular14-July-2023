{"ast":null,"code":"'use strict';\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  (function (global) {\n    var OriginalDate = global.Date; // Since when we compile this file to `es2015`, and if we define\n    // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n    // there will be an error which is `Cannot assign to read only property 'prototype'`\n    // so we need to use function implementation here.\n\n    function FakeDate() {\n      if (arguments.length === 0) {\n        var d = new OriginalDate();\n        d.setTime(FakeDate.now());\n        return d;\n      } else {\n        var args = Array.prototype.slice.call(arguments);\n        return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n      }\n    }\n\n    FakeDate.now = function () {\n      var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n      if (fakeAsyncTestZoneSpec) {\n        return fakeAsyncTestZoneSpec.getFakeSystemTime();\n      }\n\n      return OriginalDate.now.apply(this, arguments);\n    };\n\n    FakeDate.UTC = OriginalDate.UTC;\n    FakeDate.parse = OriginalDate.parse; // keep a reference for zone patched timer function\n\n    var timers = {\n      setTimeout: global.setTimeout,\n      setInterval: global.setInterval,\n      clearTimeout: global.clearTimeout,\n      clearInterval: global.clearInterval\n    };\n\n    var Scheduler =\n    /** @class */\n    function () {\n      function Scheduler() {\n        // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n        this._schedulerQueue = []; // Current simulated time in millis.\n\n        this._currentTickTime = 0; // Current fake system base time in millis.\n\n        this._currentFakeBaseSystemTime = OriginalDate.now(); // track requeuePeriodicTimer\n\n        this._currentTickRequeuePeriodicEntries = [];\n      }\n\n      Scheduler.prototype.getCurrentTickTime = function () {\n        return this._currentTickTime;\n      };\n\n      Scheduler.prototype.getFakeSystemTime = function () {\n        return this._currentFakeBaseSystemTime + this._currentTickTime;\n      };\n\n      Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n        this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n      };\n\n      Scheduler.prototype.getRealSystemTime = function () {\n        return OriginalDate.now();\n      };\n\n      Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n        options = Object.assign({\n          args: [],\n          isPeriodic: false,\n          isRequestAnimationFrame: false,\n          id: -1,\n          isRequeuePeriodic: false\n        }, options);\n        var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n        var endTime = this._currentTickTime + delay; // Insert so that scheduler queue remains sorted by end time.\n\n        var newEntry = {\n          endTime: endTime,\n          id: currentId,\n          func: cb,\n          args: options.args,\n          delay: delay,\n          isPeriodic: options.isPeriodic,\n          isRequestAnimationFrame: options.isRequestAnimationFrame\n        };\n\n        if (options.isRequeuePeriodic) {\n          this._currentTickRequeuePeriodicEntries.push(newEntry);\n        }\n\n        var i = 0;\n\n        for (; i < this._schedulerQueue.length; i++) {\n          var currentEntry = this._schedulerQueue[i];\n\n          if (newEntry.endTime < currentEntry.endTime) {\n            break;\n          }\n        }\n\n        this._schedulerQueue.splice(i, 0, newEntry);\n\n        return currentId;\n      };\n\n      Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n        for (var i = 0; i < this._schedulerQueue.length; i++) {\n          if (this._schedulerQueue[i].id == id) {\n            this._schedulerQueue.splice(i, 1);\n\n            break;\n          }\n        }\n      };\n\n      Scheduler.prototype.removeAll = function () {\n        this._schedulerQueue = [];\n      };\n\n      Scheduler.prototype.getTimerCount = function () {\n        return this._schedulerQueue.length;\n      };\n\n      Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n        if (step === void 0) {\n          step = 1;\n        }\n\n        if (this._schedulerQueue.length < step) {\n          return;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var targetTask = this._schedulerQueue[step - 1];\n        this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n      };\n\n      Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        var finalTime = this._currentTickTime + millis;\n        var lastCurrentTime = 0;\n        tickOptions = Object.assign({\n          processNewMacroTasksSynchronously: true\n        }, tickOptions); // we need to copy the schedulerQueue so nested timeout\n        // will not be wrongly called in the current tick\n        // https://github.com/angular/angular/issues/33799\n\n        var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ? this._schedulerQueue : this._schedulerQueue.slice();\n\n        if (schedulerQueue.length === 0 && doTick) {\n          doTick(millis);\n          return;\n        }\n\n        while (schedulerQueue.length > 0) {\n          // clear requeueEntries before each loop\n          this._currentTickRequeuePeriodicEntries = [];\n          var current = schedulerQueue[0];\n\n          if (finalTime < current.endTime) {\n            // Done processing the queue since it's sorted by endTime.\n            break;\n          } else {\n            // Time to run scheduled function. Remove it from the head of queue.\n            var current_1 = schedulerQueue.shift();\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              var idx = this._schedulerQueue.indexOf(current_1);\n\n              if (idx >= 0) {\n                this._schedulerQueue.splice(idx, 1);\n              }\n            }\n\n            lastCurrentTime = this._currentTickTime;\n            this._currentTickTime = current_1.endTime;\n\n            if (doTick) {\n              doTick(this._currentTickTime - lastCurrentTime);\n            }\n\n            var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n\n            if (!retval) {\n              // Uncaught exception in the current scheduled function. Stop processing the queue.\n              break;\n            } // check is there any requeue periodic entry is added in\n            // current loop, if there is, we need to add to current loop\n\n\n            if (!tickOptions.processNewMacroTasksSynchronously) {\n              this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                var i = 0;\n\n                for (; i < schedulerQueue.length; i++) {\n                  var currentEntry = schedulerQueue[i];\n\n                  if (newEntry.endTime < currentEntry.endTime) {\n                    break;\n                  }\n                }\n\n                schedulerQueue.splice(i, 0, newEntry);\n              });\n            }\n          }\n        }\n\n        lastCurrentTime = this._currentTickTime;\n        this._currentTickTime = finalTime;\n\n        if (doTick) {\n          doTick(this._currentTickTime - lastCurrentTime);\n        }\n      };\n\n      Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick, {\n          processNewMacroTasksSynchronously: false\n        });\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n        if (limit === void 0) {\n          limit = 20;\n        }\n\n        if (flushPeriodic === void 0) {\n          flushPeriodic = false;\n        }\n\n        if (flushPeriodic) {\n          return this.flushPeriodic(doTick);\n        } else {\n          return this.flushNonPeriodic(limit, doTick);\n        }\n      };\n\n      Scheduler.prototype.flushPeriodic = function (doTick) {\n        if (this._schedulerQueue.length === 0) {\n          return 0;\n        } // Find the last task currently queued in the scheduler queue and tick\n        // till that time.\n\n\n        var startTime = this._currentTickTime;\n        var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n        this.tick(lastTask.endTime - startTime, doTick);\n        return this._currentTickTime - startTime;\n      };\n\n      Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n        var startTime = this._currentTickTime;\n        var lastCurrentTime = 0;\n        var count = 0;\n\n        while (this._schedulerQueue.length > 0) {\n          count++;\n\n          if (count > limit) {\n            throw new Error('flush failed after reaching the limit of ' + limit + ' tasks. Does your code use a polling timeout?');\n          } // flush only non-periodic timers.\n          // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n\n\n          if (this._schedulerQueue.filter(function (task) {\n            return !task.isPeriodic && !task.isRequestAnimationFrame;\n          }).length === 0) {\n            break;\n          }\n\n          var current = this._schedulerQueue.shift();\n\n          lastCurrentTime = this._currentTickTime;\n          this._currentTickTime = current.endTime;\n\n          if (doTick) {\n            // Update any secondary schedulers like Jasmine mock Date.\n            doTick(this._currentTickTime - lastCurrentTime);\n          }\n\n          var retval = current.func.apply(global, current.args);\n\n          if (!retval) {\n            // Uncaught exception in the current scheduled function. Stop processing the queue.\n            break;\n          }\n        }\n\n        return this._currentTickTime - startTime;\n      };\n\n      return Scheduler;\n    }(); // Next scheduler id.\n\n\n    Scheduler.nextId = 1;\n\n    var FakeAsyncTestZoneSpec =\n    /** @class */\n    function () {\n      function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n        if (trackPendingRequestAnimationFrame === void 0) {\n          trackPendingRequestAnimationFrame = false;\n        }\n\n        this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n        this.macroTaskOptions = macroTaskOptions;\n        this._scheduler = new Scheduler();\n        this._microtasks = [];\n        this._lastError = null;\n        this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n        this.patchDateLocked = false;\n        this.properties = {\n          'FakeAsyncTestZoneSpec': this\n        };\n        this.name = 'fakeAsyncTestZone for ' + namePrefix; // in case user can't access the construction of FakeAsyncTestSpec\n        // user can also define macroTaskOptions by define a global variable.\n\n        if (!this.macroTaskOptions) {\n          this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n        }\n      }\n\n      FakeAsyncTestZoneSpec.assertInZone = function () {\n        if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n        var _this = this;\n\n        return function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          fn.apply(global, args);\n\n          if (_this._lastError === null) {\n            // Success\n            if (completers.onSuccess != null) {\n              completers.onSuccess.apply(global);\n            } // Flush microtasks only on success.\n\n\n            _this.flushMicrotasks();\n          } else {\n            // Failure\n            if (completers.onError != null) {\n              completers.onError.apply(global);\n            }\n          } // Return true if there were no errors, false otherwise.\n\n\n          return _this._lastError === null;\n        };\n      };\n\n      FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n        var index = timers.indexOf(id);\n\n        if (index > -1) {\n          timers.splice(index, 1);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n        var _this = this;\n\n        return function () {\n          // Requeue the timer callback if it's not been canceled.\n          if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n            _this._scheduler.scheduleFunction(fn, interval, {\n              args: args,\n              isPeriodic: true,\n              id: id,\n              isRequeuePeriodic: true\n            });\n          }\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n        var _this = this;\n\n        return function () {\n          FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n        };\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n        if (isTimer === void 0) {\n          isTimer = true;\n        }\n\n        var removeTimerFn = this._dequeueTimer(Scheduler.nextId); // Queue the callback and dequeue the timer on success and error.\n\n\n        var cb = this._fnAndFlush(fn, {\n          onSuccess: removeTimerFn,\n          onError: removeTimerFn\n        });\n\n        var id = this._scheduler.scheduleFunction(cb, delay, {\n          args: args,\n          isRequestAnimationFrame: !isTimer\n        });\n\n        if (isTimer) {\n          this.pendingTimers.push(id);\n        }\n\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n        var id = Scheduler.nextId;\n        var completers = {\n          onSuccess: null,\n          onError: this._dequeuePeriodicTimer(id)\n        };\n\n        var cb = this._fnAndFlush(fn, completers); // Use the callback created above to requeue on success.\n\n\n        completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id); // Queue the callback and dequeue the periodic timer only on error.\n\n        this._scheduler.scheduleFunction(cb, interval, {\n          args: args,\n          isPeriodic: true\n        });\n\n        this.pendingPeriodicTimers.push(id);\n        return id;\n      };\n\n      FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n        FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n\n        this._scheduler.removeScheduledFunctionWithId(id);\n      };\n\n      FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n        var error = this._lastError || this._uncaughtPromiseErrors[0];\n        this._uncaughtPromiseErrors.length = 0;\n        this._lastError = null;\n        throw error;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n        return this._scheduler.getCurrentTickTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n        return this._scheduler.getFakeSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n        this._scheduler.setFakeBaseSystemTime(realTime);\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n        return this._scheduler.getRealSystemTime();\n      };\n\n      FakeAsyncTestZoneSpec.patchDate = function () {\n        if (!!global[Zone.__symbol__('disableDatePatching')]) {\n          // we don't want to patch global Date\n          // because in some case, global Date\n          // is already being patched, we need to provide\n          // an option to let user still use their\n          // own version of Date.\n          return;\n        }\n\n        if (global['Date'] === FakeDate) {\n          // already patched\n          return;\n        }\n\n        global['Date'] = FakeDate;\n        FakeDate.prototype = OriginalDate.prototype; // try check and reset timers\n        // because jasmine.clock().install() may\n        // have replaced the global timer\n\n        FakeAsyncTestZoneSpec.checkTimerPatch();\n      };\n\n      FakeAsyncTestZoneSpec.resetDate = function () {\n        if (global['Date'] === FakeDate) {\n          global['Date'] = OriginalDate;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n        if (global.setTimeout !== timers.setTimeout) {\n          global.setTimeout = timers.setTimeout;\n          global.clearTimeout = timers.clearTimeout;\n        }\n\n        if (global.setInterval !== timers.setInterval) {\n          global.setInterval = timers.setInterval;\n          global.clearInterval = timers.clearInterval;\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n        this.patchDateLocked = true;\n        FakeAsyncTestZoneSpec.patchDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n        this.patchDateLocked = false;\n        FakeAsyncTestZoneSpec.resetDate();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n        if (steps === void 0) {\n          steps = 1;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        if (steps <= 0) {\n          return;\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tickToNext(steps, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n        if (millis === void 0) {\n          millis = 0;\n        }\n\n        if (tickOptions === void 0) {\n          tickOptions = {\n            processNewMacroTasksSynchronously: true\n          };\n        }\n\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        this._scheduler.tick(millis, doTick, tickOptions);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n        var _this = this;\n\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        var flushErrors = function () {\n          if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n            // If there is an error stop processing the microtask queue and rethrow the error.\n            _this._resetLastErrorAndThrow();\n          }\n        };\n\n        while (this._microtasks.length > 0) {\n          var microtask = this._microtasks.shift();\n\n          microtask.func.apply(microtask.target, microtask.args);\n        }\n\n        flushErrors();\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n        FakeAsyncTestZoneSpec.assertInZone();\n        this.flushMicrotasks();\n\n        var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n\n        if (this._lastError !== null) {\n          this._resetLastErrorAndThrow();\n        }\n\n        return elapsed;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n        FakeAsyncTestZoneSpec.assertInZone();\n\n        this._scheduler.removeAll();\n\n        this.pendingPeriodicTimers = [];\n        this.pendingTimers = [];\n      };\n\n      FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n        return this._scheduler.getTimerCount() + this._microtasks.length;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        switch (task.type) {\n          case 'microTask':\n            var args = task.data && task.data.args; // should pass additional arguments to callback if have any\n            // currently we know process.nextTick will have such additional\n            // arguments\n\n            var additionalArgs = void 0;\n\n            if (args) {\n              var callbackIndex = task.data.cbIdx;\n\n              if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n              }\n            }\n\n            this._microtasks.push({\n              func: task.invoke,\n              args: additionalArgs,\n              target: task.data && task.data.target\n            });\n\n            break;\n\n          case 'macroTask':\n            switch (task.source) {\n              case 'setTimeout':\n                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'setImmediate':\n                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                break;\n\n              case 'setInterval':\n                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                break;\n\n              case 'XMLHttpRequest.send':\n                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' + task.data['url']);\n\n              case 'requestAnimationFrame':\n              case 'webkitRequestAnimationFrame':\n              case 'mozRequestAnimationFrame':\n                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                // (60 frames per second)\n                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                break;\n\n              default:\n                // user can define which macroTask they want to support by passing\n                // macroTaskOptions\n                var macroTaskOption = this.findMacroTaskOption(task);\n\n                if (macroTaskOption) {\n                  var args_1 = task.data && task.data['args'];\n                  var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                  var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n\n                  if (!!macroTaskOption.isPeriodic) {\n                    // periodic macroTask, use setInterval to simulate\n                    task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                    task.data.isPeriodic = true;\n                  } else {\n                    // not periodic, use setTimeout to simulate\n                    task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                  }\n\n                  break;\n                }\n\n                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n            }\n\n            break;\n\n          case 'eventTask':\n            task = delegate.scheduleTask(target, task);\n            break;\n        }\n\n        return task;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        switch (task.source) {\n          case 'setTimeout':\n          case 'requestAnimationFrame':\n          case 'webkitRequestAnimationFrame':\n          case 'mozRequestAnimationFrame':\n            return this._clearTimeout(task.data['handleId']);\n\n          case 'setInterval':\n            return this._clearInterval(task.data['handleId']);\n\n          default:\n            // user can define which macroTask they want to support by passing\n            // macroTaskOptions\n            var macroTaskOption = this.findMacroTaskOption(task);\n\n            if (macroTaskOption) {\n              var handleId = task.data['handleId'];\n              return macroTaskOption.isPeriodic ? this._clearInterval(handleId) : this._clearTimeout(handleId);\n            }\n\n            return delegate.cancelTask(target, task);\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n        try {\n          FakeAsyncTestZoneSpec.patchDate();\n          return delegate.invoke(target, callback, applyThis, applyArgs, source);\n        } finally {\n          if (!this.patchDateLocked) {\n            FakeAsyncTestZoneSpec.resetDate();\n          }\n        }\n      };\n\n      FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n        if (!this.macroTaskOptions) {\n          return null;\n        }\n\n        for (var i = 0; i < this.macroTaskOptions.length; i++) {\n          var macroTaskOption = this.macroTaskOptions[i];\n\n          if (macroTaskOption.source === task.source) {\n            return macroTaskOption;\n          }\n        }\n\n        return null;\n      };\n\n      FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        this._lastError = error;\n        return false; // Don't propagate error to parent zone.\n      };\n\n      return FakeAsyncTestZoneSpec;\n    }(); // Export the class so that new instances can be created with proper\n    // constructor params.\n\n\n    Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n  })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n\n  Zone.__load_patch('fakeasync', function (global, Zone, api) {\n    var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n\n    function getProxyZoneSpec() {\n      return Zone && Zone['ProxyZoneSpec'];\n    }\n\n    var _fakeAsyncTestZoneSpec = null;\n    /**\n     * Clears out the shared fake async zone for a test.\n     * To be called in a global `beforeEach`.\n     *\n     * @experimental\n     */\n\n    function resetFakeAsyncZone() {\n      if (_fakeAsyncTestZoneSpec) {\n        _fakeAsyncTestZoneSpec.unlockDatePatch();\n      }\n\n      _fakeAsyncTestZoneSpec = null; // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n\n      getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n    }\n    /**\n     * Wraps a function to be executed in the fakeAsync zone:\n     * - microtasks are manually executed by calling `flushMicrotasks()`,\n     * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n     *\n     * If there are any pending timers at the end of the function, an exception will be thrown.\n     *\n     * Can be used to wrap inject() calls.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @param fn\n     * @returns The function wrapped to be executed in the fakeAsync zone\n     *\n     * @experimental\n     */\n\n\n    function fakeAsync(fn) {\n      // Not using an arrow function to preserve context passed from call site\n      var fakeAsyncFn = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var ProxyZoneSpec = getProxyZoneSpec();\n\n        if (!ProxyZoneSpec) {\n          throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/dist/proxy.js');\n        }\n\n        var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n\n        if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        try {\n          // in case jasmine.clock init a fakeAsyncTestZoneSpec\n          if (!_fakeAsyncTestZoneSpec) {\n            if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n              throw new Error('fakeAsync() calls can not be nested');\n            }\n\n            _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n          }\n\n          var res = void 0;\n          var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n          proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n\n          _fakeAsyncTestZoneSpec.lockDatePatch();\n\n          try {\n            res = fn.apply(this, args);\n            flushMicrotasks();\n          } finally {\n            proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" + \"periodic timer(s) still in the queue.\");\n          }\n\n          if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n            throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n          }\n\n          return res;\n        } finally {\n          resetFakeAsyncZone();\n        }\n      };\n\n      fakeAsyncFn.isFakeAsync = true;\n      return fakeAsyncFn;\n    }\n\n    function _getFakeAsyncZoneSpec() {\n      if (_fakeAsyncTestZoneSpec == null) {\n        _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n        if (_fakeAsyncTestZoneSpec == null) {\n          throw new Error('The code should be running in the fakeAsync zone to call this function');\n        }\n      }\n\n      return _fakeAsyncTestZoneSpec;\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n     *\n     * The microtasks queue is drained at the very start of this function and after any timer callback\n     * has been executed.\n     *\n     * ## Example\n     *\n     * {@example core/testing/ts/fake_async.ts region='basic'}\n     *\n     * @experimental\n     */\n\n\n    function tick(millis, ignoreNestedTimeout) {\n      if (millis === void 0) {\n        millis = 0;\n      }\n\n      if (ignoreNestedTimeout === void 0) {\n        ignoreNestedTimeout = false;\n      }\n\n      _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n    }\n    /**\n     * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n     * draining the macrotask queue until it is empty. The returned value is the milliseconds\n     * of time that would have been elapsed.\n     *\n     * @param maxTurns\n     * @returns The simulated time elapsed, in millis.\n     *\n     * @experimental\n     */\n\n\n    function flush(maxTurns) {\n      return _getFakeAsyncZoneSpec().flush(maxTurns);\n    }\n    /**\n     * Discard all remaining periodic tasks.\n     *\n     * @experimental\n     */\n\n\n    function discardPeriodicTasks() {\n      var zoneSpec = _getFakeAsyncZoneSpec();\n\n      var pendingTimers = zoneSpec.pendingPeriodicTimers;\n      zoneSpec.pendingPeriodicTimers.length = 0;\n    }\n    /**\n     * Flush any pending microtasks.\n     *\n     * @experimental\n     */\n\n\n    function flushMicrotasks() {\n      _getFakeAsyncZoneSpec().flushMicrotasks();\n    }\n\n    Zone[api.symbol('fakeAsyncTest')] = {\n      resetFakeAsyncZone: resetFakeAsyncZone,\n      flushMicrotasks: flushMicrotasks,\n      discardPeriodicTasks: discardPeriodicTasks,\n      tick: tick,\n      flush: flush,\n      fakeAsync: fakeAsync\n    };\n  }, true);\n});","map":{"version":3,"names":["__spreadArrays","s","i","il","arguments","length","r","Array","k","a","j","jl","factory","define","amd","global","OriginalDate","Date","FakeDate","d","setTime","now","args","prototype","slice","call","bind","apply","fakeAsyncTestZoneSpec","Zone","current","get","getFakeSystemTime","UTC","parse","timers","setTimeout","setInterval","clearTimeout","clearInterval","Scheduler","_schedulerQueue","_currentTickTime","_currentFakeBaseSystemTime","_currentTickRequeuePeriodicEntries","getCurrentTickTime","setFakeBaseSystemTime","fakeBaseSystemTime","getRealSystemTime","scheduleFunction","cb","delay","options","Object","assign","isPeriodic","isRequestAnimationFrame","id","isRequeuePeriodic","currentId","nextId","endTime","newEntry","func","push","currentEntry","splice","removeScheduledFunctionWithId","removeAll","getTimerCount","tickToNext","step","doTick","tickOptions","startTime","targetTask","tick","millis","finalTime","lastCurrentTime","processNewMacroTasksSynchronously","schedulerQueue","current_1","shift","idx","indexOf","retval","forEach","flushOnlyPendingTimers","lastTask","flush","limit","flushPeriodic","flushNonPeriodic","count","Error","filter","task","FakeAsyncTestZoneSpec","namePrefix","trackPendingRequestAnimationFrame","macroTaskOptions","_scheduler","_microtasks","_lastError","_uncaughtPromiseErrors","Promise","__symbol__","pendingPeriodicTimers","pendingTimers","patchDateLocked","properties","name","assertInZone","_fnAndFlush","fn","completers","_this","_i","onSuccess","flushMicrotasks","onError","_removeTimer","index","_dequeueTimer","_requeuePeriodicTimer","interval","_dequeuePeriodicTimer","_setTimeout","isTimer","removeTimerFn","_clearTimeout","_setInterval","_clearInterval","_resetLastErrorAndThrow","error","realTime","patchDate","checkTimerPatch","resetDate","lockDatePatch","unlockDatePatch","steps","flushErrors","microtask","target","elapsed","removeAllTimers","onScheduleTask","delegate","type","data","additionalArgs","callbackIndex","cbIdx","invoke","source","macroTaskOption","findMacroTaskOption","args_1","callbackArgs","scheduleTask","onCancelTask","handleId","cancelTask","onInvoke","callback","applyThis","applyArgs","onHandleError","parentZoneDelegate","currentZone","targetZone","window","self","__load_patch","api","getProxyZoneSpec","_fakeAsyncTestZoneSpec","resetFakeAsyncZone","assertPresent","resetDelegate","fakeAsync","fakeAsyncFn","ProxyZoneSpec","proxyZoneSpec","getDelegate","res","lastProxyZoneSpec","setDelegate","isFakeAsync","_getFakeAsyncZoneSpec","ignoreNestedTimeout","maxTurns","discardPeriodicTasks","zoneSpec","symbol"],"sources":["F:/Training/Virtual Training/ACE/Coforge/Angular - Spring Boot - Microservices With Spring Cloud/1. Angular 14/Day 7/Supporting Materials/Unit Testing in Angular - I/NGUNITESTING/node_modules/zone.js/dist/fake-async-test.js"],"sourcesContent":["'use strict';\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/**\n * @license Angular v12.0.0-next.0\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n}((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    (function (global) {\n        var OriginalDate = global.Date;\n        // Since when we compile this file to `es2015`, and if we define\n        // this `FakeDate` as `class FakeDate`, and then set `FakeDate.prototype`\n        // there will be an error which is `Cannot assign to read only property 'prototype'`\n        // so we need to use function implementation here.\n        function FakeDate() {\n            if (arguments.length === 0) {\n                var d = new OriginalDate();\n                d.setTime(FakeDate.now());\n                return d;\n            }\n            else {\n                var args = Array.prototype.slice.call(arguments);\n                return new (OriginalDate.bind.apply(OriginalDate, __spreadArrays([void 0], args)))();\n            }\n        }\n        FakeDate.now = function () {\n            var fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n            if (fakeAsyncTestZoneSpec) {\n                return fakeAsyncTestZoneSpec.getFakeSystemTime();\n            }\n            return OriginalDate.now.apply(this, arguments);\n        };\n        FakeDate.UTC = OriginalDate.UTC;\n        FakeDate.parse = OriginalDate.parse;\n        // keep a reference for zone patched timer function\n        var timers = {\n            setTimeout: global.setTimeout,\n            setInterval: global.setInterval,\n            clearTimeout: global.clearTimeout,\n            clearInterval: global.clearInterval\n        };\n        var Scheduler = /** @class */ (function () {\n            function Scheduler() {\n                // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n                this._schedulerQueue = [];\n                // Current simulated time in millis.\n                this._currentTickTime = 0;\n                // Current fake system base time in millis.\n                this._currentFakeBaseSystemTime = OriginalDate.now();\n                // track requeuePeriodicTimer\n                this._currentTickRequeuePeriodicEntries = [];\n            }\n            Scheduler.prototype.getCurrentTickTime = function () {\n                return this._currentTickTime;\n            };\n            Scheduler.prototype.getFakeSystemTime = function () {\n                return this._currentFakeBaseSystemTime + this._currentTickTime;\n            };\n            Scheduler.prototype.setFakeBaseSystemTime = function (fakeBaseSystemTime) {\n                this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n            };\n            Scheduler.prototype.getRealSystemTime = function () {\n                return OriginalDate.now();\n            };\n            Scheduler.prototype.scheduleFunction = function (cb, delay, options) {\n                options = Object.assign({\n                    args: [],\n                    isPeriodic: false,\n                    isRequestAnimationFrame: false,\n                    id: -1,\n                    isRequeuePeriodic: false\n                }, options);\n                var currentId = options.id < 0 ? Scheduler.nextId++ : options.id;\n                var endTime = this._currentTickTime + delay;\n                // Insert so that scheduler queue remains sorted by end time.\n                var newEntry = {\n                    endTime: endTime,\n                    id: currentId,\n                    func: cb,\n                    args: options.args,\n                    delay: delay,\n                    isPeriodic: options.isPeriodic,\n                    isRequestAnimationFrame: options.isRequestAnimationFrame\n                };\n                if (options.isRequeuePeriodic) {\n                    this._currentTickRequeuePeriodicEntries.push(newEntry);\n                }\n                var i = 0;\n                for (; i < this._schedulerQueue.length; i++) {\n                    var currentEntry = this._schedulerQueue[i];\n                    if (newEntry.endTime < currentEntry.endTime) {\n                        break;\n                    }\n                }\n                this._schedulerQueue.splice(i, 0, newEntry);\n                return currentId;\n            };\n            Scheduler.prototype.removeScheduledFunctionWithId = function (id) {\n                for (var i = 0; i < this._schedulerQueue.length; i++) {\n                    if (this._schedulerQueue[i].id == id) {\n                        this._schedulerQueue.splice(i, 1);\n                        break;\n                    }\n                }\n            };\n            Scheduler.prototype.removeAll = function () {\n                this._schedulerQueue = [];\n            };\n            Scheduler.prototype.getTimerCount = function () {\n                return this._schedulerQueue.length;\n            };\n            Scheduler.prototype.tickToNext = function (step, doTick, tickOptions) {\n                if (step === void 0) { step = 1; }\n                if (this._schedulerQueue.length < step) {\n                    return;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var targetTask = this._schedulerQueue[step - 1];\n                this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n            };\n            Scheduler.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                var finalTime = this._currentTickTime + millis;\n                var lastCurrentTime = 0;\n                tickOptions = Object.assign({ processNewMacroTasksSynchronously: true }, tickOptions);\n                // we need to copy the schedulerQueue so nested timeout\n                // will not be wrongly called in the current tick\n                // https://github.com/angular/angular/issues/33799\n                var schedulerQueue = tickOptions.processNewMacroTasksSynchronously ?\n                    this._schedulerQueue :\n                    this._schedulerQueue.slice();\n                if (schedulerQueue.length === 0 && doTick) {\n                    doTick(millis);\n                    return;\n                }\n                while (schedulerQueue.length > 0) {\n                    // clear requeueEntries before each loop\n                    this._currentTickRequeuePeriodicEntries = [];\n                    var current = schedulerQueue[0];\n                    if (finalTime < current.endTime) {\n                        // Done processing the queue since it's sorted by endTime.\n                        break;\n                    }\n                    else {\n                        // Time to run scheduled function. Remove it from the head of queue.\n                        var current_1 = schedulerQueue.shift();\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            var idx = this._schedulerQueue.indexOf(current_1);\n                            if (idx >= 0) {\n                                this._schedulerQueue.splice(idx, 1);\n                            }\n                        }\n                        lastCurrentTime = this._currentTickTime;\n                        this._currentTickTime = current_1.endTime;\n                        if (doTick) {\n                            doTick(this._currentTickTime - lastCurrentTime);\n                        }\n                        var retval = current_1.func.apply(global, current_1.isRequestAnimationFrame ? [this._currentTickTime] : current_1.args);\n                        if (!retval) {\n                            // Uncaught exception in the current scheduled function. Stop processing the queue.\n                            break;\n                        }\n                        // check is there any requeue periodic entry is added in\n                        // current loop, if there is, we need to add to current loop\n                        if (!tickOptions.processNewMacroTasksSynchronously) {\n                            this._currentTickRequeuePeriodicEntries.forEach(function (newEntry) {\n                                var i = 0;\n                                for (; i < schedulerQueue.length; i++) {\n                                    var currentEntry = schedulerQueue[i];\n                                    if (newEntry.endTime < currentEntry.endTime) {\n                                        break;\n                                    }\n                                }\n                                schedulerQueue.splice(i, 0, newEntry);\n                            });\n                        }\n                    }\n                }\n                lastCurrentTime = this._currentTickTime;\n                this._currentTickTime = finalTime;\n                if (doTick) {\n                    doTick(this._currentTickTime - lastCurrentTime);\n                }\n            };\n            Scheduler.prototype.flushOnlyPendingTimers = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick, { processNewMacroTasksSynchronously: false });\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flush = function (limit, flushPeriodic, doTick) {\n                if (limit === void 0) { limit = 20; }\n                if (flushPeriodic === void 0) { flushPeriodic = false; }\n                if (flushPeriodic) {\n                    return this.flushPeriodic(doTick);\n                }\n                else {\n                    return this.flushNonPeriodic(limit, doTick);\n                }\n            };\n            Scheduler.prototype.flushPeriodic = function (doTick) {\n                if (this._schedulerQueue.length === 0) {\n                    return 0;\n                }\n                // Find the last task currently queued in the scheduler queue and tick\n                // till that time.\n                var startTime = this._currentTickTime;\n                var lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n                this.tick(lastTask.endTime - startTime, doTick);\n                return this._currentTickTime - startTime;\n            };\n            Scheduler.prototype.flushNonPeriodic = function (limit, doTick) {\n                var startTime = this._currentTickTime;\n                var lastCurrentTime = 0;\n                var count = 0;\n                while (this._schedulerQueue.length > 0) {\n                    count++;\n                    if (count > limit) {\n                        throw new Error('flush failed after reaching the limit of ' + limit +\n                            ' tasks. Does your code use a polling timeout?');\n                    }\n                    // flush only non-periodic timers.\n                    // If the only remaining tasks are periodic(or requestAnimationFrame), finish flushing.\n                    if (this._schedulerQueue.filter(function (task) { return !task.isPeriodic && !task.isRequestAnimationFrame; })\n                        .length === 0) {\n                        break;\n                    }\n                    var current = this._schedulerQueue.shift();\n                    lastCurrentTime = this._currentTickTime;\n                    this._currentTickTime = current.endTime;\n                    if (doTick) {\n                        // Update any secondary schedulers like Jasmine mock Date.\n                        doTick(this._currentTickTime - lastCurrentTime);\n                    }\n                    var retval = current.func.apply(global, current.args);\n                    if (!retval) {\n                        // Uncaught exception in the current scheduled function. Stop processing the queue.\n                        break;\n                    }\n                }\n                return this._currentTickTime - startTime;\n            };\n            return Scheduler;\n        }());\n        // Next scheduler id.\n        Scheduler.nextId = 1;\n        var FakeAsyncTestZoneSpec = /** @class */ (function () {\n            function FakeAsyncTestZoneSpec(namePrefix, trackPendingRequestAnimationFrame, macroTaskOptions) {\n                if (trackPendingRequestAnimationFrame === void 0) { trackPendingRequestAnimationFrame = false; }\n                this.trackPendingRequestAnimationFrame = trackPendingRequestAnimationFrame;\n                this.macroTaskOptions = macroTaskOptions;\n                this._scheduler = new Scheduler();\n                this._microtasks = [];\n                this._lastError = null;\n                this._uncaughtPromiseErrors = Promise[Zone.__symbol__('uncaughtPromiseErrors')];\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n                this.patchDateLocked = false;\n                this.properties = { 'FakeAsyncTestZoneSpec': this };\n                this.name = 'fakeAsyncTestZone for ' + namePrefix;\n                // in case user can't access the construction of FakeAsyncTestSpec\n                // user can also define macroTaskOptions by define a global variable.\n                if (!this.macroTaskOptions) {\n                    this.macroTaskOptions = global[Zone.__symbol__('FakeAsyncTestMacroTask')];\n                }\n            }\n            FakeAsyncTestZoneSpec.assertInZone = function () {\n                if (Zone.current.get('FakeAsyncTestZoneSpec') == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._fnAndFlush = function (fn, completers) {\n                var _this = this;\n                return function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    fn.apply(global, args);\n                    if (_this._lastError === null) { // Success\n                        if (completers.onSuccess != null) {\n                            completers.onSuccess.apply(global);\n                        }\n                        // Flush microtasks only on success.\n                        _this.flushMicrotasks();\n                    }\n                    else { // Failure\n                        if (completers.onError != null) {\n                            completers.onError.apply(global);\n                        }\n                    }\n                    // Return true if there were no errors, false otherwise.\n                    return _this._lastError === null;\n                };\n            };\n            FakeAsyncTestZoneSpec._removeTimer = function (timers, id) {\n                var index = timers.indexOf(id);\n                if (index > -1) {\n                    timers.splice(index, 1);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeueTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._requeuePeriodicTimer = function (fn, interval, args, id) {\n                var _this = this;\n                return function () {\n                    // Requeue the timer callback if it's not been canceled.\n                    if (_this.pendingPeriodicTimers.indexOf(id) !== -1) {\n                        _this._scheduler.scheduleFunction(fn, interval, { args: args, isPeriodic: true, id: id, isRequeuePeriodic: true });\n                    }\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._dequeuePeriodicTimer = function (id) {\n                var _this = this;\n                return function () {\n                    FakeAsyncTestZoneSpec._removeTimer(_this.pendingPeriodicTimers, id);\n                };\n            };\n            FakeAsyncTestZoneSpec.prototype._setTimeout = function (fn, delay, args, isTimer) {\n                if (isTimer === void 0) { isTimer = true; }\n                var removeTimerFn = this._dequeueTimer(Scheduler.nextId);\n                // Queue the callback and dequeue the timer on success and error.\n                var cb = this._fnAndFlush(fn, { onSuccess: removeTimerFn, onError: removeTimerFn });\n                var id = this._scheduler.scheduleFunction(cb, delay, { args: args, isRequestAnimationFrame: !isTimer });\n                if (isTimer) {\n                    this.pendingTimers.push(id);\n                }\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearTimeout = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._setInterval = function (fn, interval, args) {\n                var id = Scheduler.nextId;\n                var completers = { onSuccess: null, onError: this._dequeuePeriodicTimer(id) };\n                var cb = this._fnAndFlush(fn, completers);\n                // Use the callback created above to requeue on success.\n                completers.onSuccess = this._requeuePeriodicTimer(cb, interval, args, id);\n                // Queue the callback and dequeue the periodic timer only on error.\n                this._scheduler.scheduleFunction(cb, interval, { args: args, isPeriodic: true });\n                this.pendingPeriodicTimers.push(id);\n                return id;\n            };\n            FakeAsyncTestZoneSpec.prototype._clearInterval = function (id) {\n                FakeAsyncTestZoneSpec._removeTimer(this.pendingPeriodicTimers, id);\n                this._scheduler.removeScheduledFunctionWithId(id);\n            };\n            FakeAsyncTestZoneSpec.prototype._resetLastErrorAndThrow = function () {\n                var error = this._lastError || this._uncaughtPromiseErrors[0];\n                this._uncaughtPromiseErrors.length = 0;\n                this._lastError = null;\n                throw error;\n            };\n            FakeAsyncTestZoneSpec.prototype.getCurrentTickTime = function () {\n                return this._scheduler.getCurrentTickTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.getFakeSystemTime = function () {\n                return this._scheduler.getFakeSystemTime();\n            };\n            FakeAsyncTestZoneSpec.prototype.setFakeBaseSystemTime = function (realTime) {\n                this._scheduler.setFakeBaseSystemTime(realTime);\n            };\n            FakeAsyncTestZoneSpec.prototype.getRealSystemTime = function () {\n                return this._scheduler.getRealSystemTime();\n            };\n            FakeAsyncTestZoneSpec.patchDate = function () {\n                if (!!global[Zone.__symbol__('disableDatePatching')]) {\n                    // we don't want to patch global Date\n                    // because in some case, global Date\n                    // is already being patched, we need to provide\n                    // an option to let user still use their\n                    // own version of Date.\n                    return;\n                }\n                if (global['Date'] === FakeDate) {\n                    // already patched\n                    return;\n                }\n                global['Date'] = FakeDate;\n                FakeDate.prototype = OriginalDate.prototype;\n                // try check and reset timers\n                // because jasmine.clock().install() may\n                // have replaced the global timer\n                FakeAsyncTestZoneSpec.checkTimerPatch();\n            };\n            FakeAsyncTestZoneSpec.resetDate = function () {\n                if (global['Date'] === FakeDate) {\n                    global['Date'] = OriginalDate;\n                }\n            };\n            FakeAsyncTestZoneSpec.checkTimerPatch = function () {\n                if (global.setTimeout !== timers.setTimeout) {\n                    global.setTimeout = timers.setTimeout;\n                    global.clearTimeout = timers.clearTimeout;\n                }\n                if (global.setInterval !== timers.setInterval) {\n                    global.setInterval = timers.setInterval;\n                    global.clearInterval = timers.clearInterval;\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.lockDatePatch = function () {\n                this.patchDateLocked = true;\n                FakeAsyncTestZoneSpec.patchDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.unlockDatePatch = function () {\n                this.patchDateLocked = false;\n                FakeAsyncTestZoneSpec.resetDate();\n            };\n            FakeAsyncTestZoneSpec.prototype.tickToNext = function (steps, doTick, tickOptions) {\n                if (steps === void 0) { steps = 1; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                if (steps <= 0) {\n                    return;\n                }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tickToNext(steps, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.tick = function (millis, doTick, tickOptions) {\n                if (millis === void 0) { millis = 0; }\n                if (tickOptions === void 0) { tickOptions = { processNewMacroTasksSynchronously: true }; }\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                this._scheduler.tick(millis, doTick, tickOptions);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.flushMicrotasks = function () {\n                var _this = this;\n                FakeAsyncTestZoneSpec.assertInZone();\n                var flushErrors = function () {\n                    if (_this._lastError !== null || _this._uncaughtPromiseErrors.length) {\n                        // If there is an error stop processing the microtask queue and rethrow the error.\n                        _this._resetLastErrorAndThrow();\n                    }\n                };\n                while (this._microtasks.length > 0) {\n                    var microtask = this._microtasks.shift();\n                    microtask.func.apply(microtask.target, microtask.args);\n                }\n                flushErrors();\n            };\n            FakeAsyncTestZoneSpec.prototype.flush = function (limit, flushPeriodic, doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flush(limit, flushPeriodic, doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.flushOnlyPendingTimers = function (doTick) {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this.flushMicrotasks();\n                var elapsed = this._scheduler.flushOnlyPendingTimers(doTick);\n                if (this._lastError !== null) {\n                    this._resetLastErrorAndThrow();\n                }\n                return elapsed;\n            };\n            FakeAsyncTestZoneSpec.prototype.removeAllTimers = function () {\n                FakeAsyncTestZoneSpec.assertInZone();\n                this._scheduler.removeAll();\n                this.pendingPeriodicTimers = [];\n                this.pendingTimers = [];\n            };\n            FakeAsyncTestZoneSpec.prototype.getTimerCount = function () {\n                return this._scheduler.getTimerCount() + this._microtasks.length;\n            };\n            FakeAsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n                switch (task.type) {\n                    case 'microTask':\n                        var args = task.data && task.data.args;\n                        // should pass additional arguments to callback if have any\n                        // currently we know process.nextTick will have such additional\n                        // arguments\n                        var additionalArgs = void 0;\n                        if (args) {\n                            var callbackIndex = task.data.cbIdx;\n                            if (typeof args.length === 'number' && args.length > callbackIndex + 1) {\n                                additionalArgs = Array.prototype.slice.call(args, callbackIndex + 1);\n                            }\n                        }\n                        this._microtasks.push({\n                            func: task.invoke,\n                            args: additionalArgs,\n                            target: task.data && task.data.target\n                        });\n                        break;\n                    case 'macroTask':\n                        switch (task.source) {\n                            case 'setTimeout':\n                                task.data['handleId'] = this._setTimeout(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'setImmediate':\n                                task.data['handleId'] = this._setTimeout(task.invoke, 0, Array.prototype.slice.call(task.data['args'], 1));\n                                break;\n                            case 'setInterval':\n                                task.data['handleId'] = this._setInterval(task.invoke, task.data['delay'], Array.prototype.slice.call(task.data['args'], 2));\n                                break;\n                            case 'XMLHttpRequest.send':\n                                throw new Error('Cannot make XHRs from within a fake async test. Request URL: ' +\n                                    task.data['url']);\n                            case 'requestAnimationFrame':\n                            case 'webkitRequestAnimationFrame':\n                            case 'mozRequestAnimationFrame':\n                                // Simulate a requestAnimationFrame by using a setTimeout with 16 ms.\n                                // (60 frames per second)\n                                task.data['handleId'] = this._setTimeout(task.invoke, 16, task.data['args'], this.trackPendingRequestAnimationFrame);\n                                break;\n                            default:\n                                // user can define which macroTask they want to support by passing\n                                // macroTaskOptions\n                                var macroTaskOption = this.findMacroTaskOption(task);\n                                if (macroTaskOption) {\n                                    var args_1 = task.data && task.data['args'];\n                                    var delay = args_1 && args_1.length > 1 ? args_1[1] : 0;\n                                    var callbackArgs = macroTaskOption.callbackArgs ? macroTaskOption.callbackArgs : args_1;\n                                    if (!!macroTaskOption.isPeriodic) {\n                                        // periodic macroTask, use setInterval to simulate\n                                        task.data['handleId'] = this._setInterval(task.invoke, delay, callbackArgs);\n                                        task.data.isPeriodic = true;\n                                    }\n                                    else {\n                                        // not periodic, use setTimeout to simulate\n                                        task.data['handleId'] = this._setTimeout(task.invoke, delay, callbackArgs);\n                                    }\n                                    break;\n                                }\n                                throw new Error('Unknown macroTask scheduled in fake async test: ' + task.source);\n                        }\n                        break;\n                    case 'eventTask':\n                        task = delegate.scheduleTask(target, task);\n                        break;\n                }\n                return task;\n            };\n            FakeAsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n                switch (task.source) {\n                    case 'setTimeout':\n                    case 'requestAnimationFrame':\n                    case 'webkitRequestAnimationFrame':\n                    case 'mozRequestAnimationFrame':\n                        return this._clearTimeout(task.data['handleId']);\n                    case 'setInterval':\n                        return this._clearInterval(task.data['handleId']);\n                    default:\n                        // user can define which macroTask they want to support by passing\n                        // macroTaskOptions\n                        var macroTaskOption = this.findMacroTaskOption(task);\n                        if (macroTaskOption) {\n                            var handleId = task.data['handleId'];\n                            return macroTaskOption.isPeriodic ? this._clearInterval(handleId) :\n                                this._clearTimeout(handleId);\n                        }\n                        return delegate.cancelTask(target, task);\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.onInvoke = function (delegate, current, target, callback, applyThis, applyArgs, source) {\n                try {\n                    FakeAsyncTestZoneSpec.patchDate();\n                    return delegate.invoke(target, callback, applyThis, applyArgs, source);\n                }\n                finally {\n                    if (!this.patchDateLocked) {\n                        FakeAsyncTestZoneSpec.resetDate();\n                    }\n                }\n            };\n            FakeAsyncTestZoneSpec.prototype.findMacroTaskOption = function (task) {\n                if (!this.macroTaskOptions) {\n                    return null;\n                }\n                for (var i = 0; i < this.macroTaskOptions.length; i++) {\n                    var macroTaskOption = this.macroTaskOptions[i];\n                    if (macroTaskOption.source === task.source) {\n                        return macroTaskOption;\n                    }\n                }\n                return null;\n            };\n            FakeAsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n                this._lastError = error;\n                return false; // Don't propagate error to parent zone.\n            };\n            return FakeAsyncTestZoneSpec;\n        }());\n        // Export the class so that new instances can be created with proper\n        // constructor params.\n        Zone['FakeAsyncTestZoneSpec'] = FakeAsyncTestZoneSpec;\n    })(typeof window === 'object' && window || typeof self === 'object' && self || global);\n    Zone.__load_patch('fakeasync', function (global, Zone, api) {\n        var FakeAsyncTestZoneSpec = Zone && Zone['FakeAsyncTestZoneSpec'];\n        function getProxyZoneSpec() {\n            return Zone && Zone['ProxyZoneSpec'];\n        }\n        var _fakeAsyncTestZoneSpec = null;\n        /**\n         * Clears out the shared fake async zone for a test.\n         * To be called in a global `beforeEach`.\n         *\n         * @experimental\n         */\n        function resetFakeAsyncZone() {\n            if (_fakeAsyncTestZoneSpec) {\n                _fakeAsyncTestZoneSpec.unlockDatePatch();\n            }\n            _fakeAsyncTestZoneSpec = null;\n            // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n            getProxyZoneSpec() && getProxyZoneSpec().assertPresent().resetDelegate();\n        }\n        /**\n         * Wraps a function to be executed in the fakeAsync zone:\n         * - microtasks are manually executed by calling `flushMicrotasks()`,\n         * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n         *\n         * If there are any pending timers at the end of the function, an exception will be thrown.\n         *\n         * Can be used to wrap inject() calls.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @param fn\n         * @returns The function wrapped to be executed in the fakeAsync zone\n         *\n         * @experimental\n         */\n        function fakeAsync(fn) {\n            // Not using an arrow function to preserve context passed from call site\n            var fakeAsyncFn = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var ProxyZoneSpec = getProxyZoneSpec();\n                if (!ProxyZoneSpec) {\n                    throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                        'Please make sure that your environment includes zone.js/dist/proxy.js');\n                }\n                var proxyZoneSpec = ProxyZoneSpec.assertPresent();\n                if (Zone.current.get('FakeAsyncTestZoneSpec')) {\n                    throw new Error('fakeAsync() calls can not be nested');\n                }\n                try {\n                    // in case jasmine.clock init a fakeAsyncTestZoneSpec\n                    if (!_fakeAsyncTestZoneSpec) {\n                        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n                            throw new Error('fakeAsync() calls can not be nested');\n                        }\n                        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n                    }\n                    var res = void 0;\n                    var lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n                    proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n                    _fakeAsyncTestZoneSpec.lockDatePatch();\n                    try {\n                        res = fn.apply(this, args);\n                        flushMicrotasks();\n                    }\n                    finally {\n                        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length + \" \" +\n                            \"periodic timer(s) still in the queue.\");\n                    }\n                    if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n                        throw new Error(_fakeAsyncTestZoneSpec.pendingTimers.length + \" timer(s) still in the queue.\");\n                    }\n                    return res;\n                }\n                finally {\n                    resetFakeAsyncZone();\n                }\n            };\n            fakeAsyncFn.isFakeAsync = true;\n            return fakeAsyncFn;\n        }\n        function _getFakeAsyncZoneSpec() {\n            if (_fakeAsyncTestZoneSpec == null) {\n                _fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                if (_fakeAsyncTestZoneSpec == null) {\n                    throw new Error('The code should be running in the fakeAsync zone to call this function');\n                }\n            }\n            return _fakeAsyncTestZoneSpec;\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n         *\n         * The microtasks queue is drained at the very start of this function and after any timer callback\n         * has been executed.\n         *\n         * ## Example\n         *\n         * {@example core/testing/ts/fake_async.ts region='basic'}\n         *\n         * @experimental\n         */\n        function tick(millis, ignoreNestedTimeout) {\n            if (millis === void 0) { millis = 0; }\n            if (ignoreNestedTimeout === void 0) { ignoreNestedTimeout = false; }\n            _getFakeAsyncZoneSpec().tick(millis, null, ignoreNestedTimeout);\n        }\n        /**\n         * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n         * draining the macrotask queue until it is empty. The returned value is the milliseconds\n         * of time that would have been elapsed.\n         *\n         * @param maxTurns\n         * @returns The simulated time elapsed, in millis.\n         *\n         * @experimental\n         */\n        function flush(maxTurns) {\n            return _getFakeAsyncZoneSpec().flush(maxTurns);\n        }\n        /**\n         * Discard all remaining periodic tasks.\n         *\n         * @experimental\n         */\n        function discardPeriodicTasks() {\n            var zoneSpec = _getFakeAsyncZoneSpec();\n            var pendingTimers = zoneSpec.pendingPeriodicTimers;\n            zoneSpec.pendingPeriodicTimers.length = 0;\n        }\n        /**\n         * Flush any pending microtasks.\n         *\n         * @experimental\n         */\n        function flushMicrotasks() {\n            _getFakeAsyncZoneSpec().flushMicrotasks();\n        }\n        Zone[api.symbol('fakeAsyncTest')] =\n            { resetFakeAsyncZone: resetFakeAsyncZone, flushMicrotasks: flushMicrotasks, discardPeriodicTasks: discardPeriodicTasks, tick: tick, flush: flush, fakeAsync: fakeAsync };\n    }, true);\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}